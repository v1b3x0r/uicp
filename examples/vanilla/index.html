<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üß™ UIP Drawer Demo</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
    }
    
    .demo-section {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    button {
      background: #007AFF;
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 6px;
      cursor: pointer;
      margin: 5px;
    }
    
    button:hover { background: #0056CC; }
    
    /* Apple-style drawer */
    .drawer {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      height: 400px;
      background: rgba(255, 255, 255, 0.98);
      backdrop-filter: blur(20px);
      border-radius: 16px 16px 0 0;
      transform: translateY(100%);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
    }
    
    .drawer.drawer-open {
      transform: translateY(0);
    }
    
    .backdrop {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(4px);
      z-index: 999;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    
    .backdrop.show {
      opacity: 1;
      visibility: visible;
    }
    
    .drawer-content {
      padding: 20px;
      flex: 0 0 auto; /* Don't grow or shrink */
      max-height: 360px; /* Fixed maximum height */
      overflow-y: auto; /* Scroll if content is too long */
    }
    
    .drawer-spacer {
      flex: 1; /* Takes all remaining space when drawer expands */
      min-height: 0;
    }
    
    .drawer-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid #eee;
    }
    
    .drawer-handle {
      width: 40px;
      height: 4px;
      background: #ccc;
      border-radius: 2px;
      margin: 10px auto;
    }
    
    #logs {
      background: #1d1d1f;
      color: #00FF41;
      font-family: monospace;
      font-size: 12px;
      padding: 10px;
      border-radius: 4px;
      max-height: 200px;
      overflow-y: auto;
      margin: 10px 0;
    }
    
    .status {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
    }
    
    .pass { background: #E8F5E8; color: #2D6A2D; }
    .fail { background: #FFF2F2; color: #A83333; }
    .info { background: #F0F8FF; color: #0066CC; }
    
    /* Test Results */
    .test-summary { padding: 10px; border-radius: 4px; margin: 10px 0; font-weight: bold; }
    .test-summary.pass { background: #E8F5E8; color: #2D6A2D; }
    .test-summary.fail { background: #FFF2F2; color: #A83333; }
    
    .test-result { display: flex; justify-content: space-between; padding: 5px 10px; border-bottom: 1px solid #eee; }
    .test-result.pass { background: #f9fff9; }
    .test-result.fail { background: #fff9f9; }
    .test-error { font-size: 11px; color: #666; margin-top: 5px; }
  </style>
</head>
<body>
  <h1>üß™ UIP Drawer Demo</h1>
  <p>Interactive drawer: drag up for fullscreen, drag down to close</p>
  
  <!-- Main Demo -->
  <div class="demo-section">
    <h2>üì± Drawer Test</h2>
    <div>
      <button id="vanilla-drawer-trigger">Open Drawer</button>
      <button id="debug-state">Debug State</button>
      <button id="clear-logs">Clear Logs</button>
    </div>
    <div id="status">
      Status: <span id="drawer-status" class="status pass">Ready</span>
    </div>
  </div>
  
  <!-- Debug Controls -->
  <div class="demo-section">
    <h3>üõ† Debug Controls</h3>
    <div>
      <button id="force-open">Force Open (CSS)</button>
      <button id="force-close">Force Close (CSS)</button>
    </div>
  </div>
  
  <!-- Logs -->
  <div class="demo-section">
    <h3>üìú Event Logs</h3>
    <div id="logs">‚úÖ World-class drawer initialized</div>
  </div>
  
  <!-- Test Results -->
  <div class="demo-section">
    <h3>üß™ Automated Tests</h3>
    <div>
      <button onclick="window.testRunner?.runTests()">Run Tests</button>
    </div>
    <div id="test-results" style="margin-top: 15px;">
      Tests will run automatically...
    </div>
  </div>
  
  <!-- Backdrop -->
  <div id="drawer-backdrop" class="backdrop"></div>
  
  <!-- Drawer -->
  <div id="test-drawer" class="drawer">
    <div class="drawer-handle"></div>
    <div class="drawer-content">
      <div class="drawer-header">
        <h3>üçé World-Class Drawer</h3>
        <button id="close-drawer">Close</button>
      </div>
      <div>
        <p>Interactive drawer with full gesture control:</p>
        <ul>
          <li>üîµ <strong>Drag up</strong> - Expand to fullscreen</li>
          <li>üî¥ <strong>Drag down</strong> - Close drawer</li>
          <li>‚úÖ Real-time finger tracking</li>
          <li>‚úÖ Velocity-based snapping</li>
          <li>‚úÖ Visual feedback colors</li>
          <li>‚úÖ Touch & mouse support</li>
          <li>‚úÖ Smooth animations</li>
        </ul>
        <p><strong>Try it:</strong> Drag this drawer up or down!</p>
      </div>
    </div>
    <div class="drawer-spacer"></div> <!-- Expands when drawer grows -->
  </div>
  
  <script>
    /**
     * World-Class Single-File Drawer Implementation
     * Framework7-inspired, zero dependencies, perfect reliability
     */
    
    // World-class drawer with iOS-like swipe gestures
    class WorldClassDrawer {
      constructor(element, backdrop) {
        this.el = element;
        this.backdrop = backdrop;
        this.opened = false;
        this.expanded = false; // Track if drawer is expanded to fullscreen
        
        // Gesture state
        this.isDragging = false;
        this.startY = 0;
        this.currentY = 0;
        this.startTime = 0;
        this.initialTranslateY = 0;
        
        this.initGestures();
      }
      
      open() {
        this.el.classList.add('drawer-open');
        this.backdrop.classList.add('show');
        this.opened = true;
        this.expanded = false; // Reset expanded state
        this.el.style.transform = 'translateY(0)'; // Ensure clean state
        this.el.style.height = '400px'; // Reset to original height
        this.log('üö™ Drawer opened');
      }
      
      close() {
        this.el.classList.remove('drawer-open');
        this.backdrop.classList.remove('show');
        this.opened = false;
        this.expanded = false; // Reset expanded state
        this.resetTransform();
        this.log('üö™ Drawer closed');
      }
      
      toggle() {
        this.opened ? this.close() : this.open();
      }
      
      initGestures() {
        // Touch events for mobile
        this.el.addEventListener('touchstart', this.handleGestureStart.bind(this), { passive: true });
        this.el.addEventListener('touchmove', this.handleGestureMove.bind(this), { passive: false });
        this.el.addEventListener('touchend', this.handleGestureEnd.bind(this), { passive: true });
        
        // Mouse events for desktop
        this.el.addEventListener('mousedown', this.handleGestureStart.bind(this));
        document.addEventListener('mousemove', this.handleGestureMove.bind(this));
        document.addEventListener('mouseup', this.handleGestureEnd.bind(this));
        
        // Define snap points
        this.SNAP_POINTS = {
          CLOSED: 400,   // translateY to close
          HALF: 0,       // normal open position
          FULL: -1       // flag for fullscreen (will calculate actual height)
        };
        
        this.currentSnap = this.SNAP_POINTS.HALF;
      }
      
      handleGestureStart(e) {
        if (!this.opened) return;
        
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        this.isDragging = true;
        this.startY = clientY;
        this.startTime = Date.now();
        this.startHeight = this.el.offsetHeight;
        
        // Get current position for smooth continuation
        const transform = window.getComputedStyle(this.el).transform;
        if (transform && transform !== 'none') {
          const matrix = new DOMMatrix(transform);
          this.startTranslateY = matrix.m42;
        } else {
          this.startTranslateY = 0;
        }
        
        // Disable transitions for immediate response
        this.el.style.transition = 'none';
        this.backdrop.style.transition = 'none';
        
        
        if (e.type === 'mousedown') e.preventDefault();
      }
      
      handleGestureMove(e) {
        if (!this.isDragging) return;
        
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        this.currentY = clientY; // Store for mouse end event
        const deltaY = clientY - this.startY;
        
        // Natural drag: up = expand, down = close
        const viewportHeight = window.innerHeight;
        const baseHeight = 400;
        
        if (deltaY > 0) {
          // Dragging down - closing motion
          const translateY = Math.min(baseHeight, this.startTranslateY + deltaY);
          this.el.style.transform = `translateY(${translateY}px)`;
          
          // Visual feedback
          const closeProgress = translateY / baseHeight;
          this.backdrop.style.opacity = Math.max(0, 1 - closeProgress * 0.8);
          
          if (closeProgress > 0.3) {
            this.el.style.boxShadow = `0 -4px 20px rgba(255, 0, 0, ${0.2 + closeProgress * 0.3})`;
          }
        } else {
          // Dragging up - expanding motion
          const expansionDelta = Math.abs(deltaY);
          const newHeight = Math.min(viewportHeight, this.startHeight + expansionDelta);
          
          // Keep drawer at bottom, increase height
          this.el.style.transform = 'translateY(0)';
          this.el.style.height = `${newHeight}px`;
          
          // Visual feedback
          const expandProgress = (newHeight - baseHeight) / (viewportHeight - baseHeight);
          this.backdrop.style.opacity = Math.min(1.5, 1 + expandProgress * 0.3);
          
          if (expandProgress > 0.2) {
            this.el.style.boxShadow = `0 -4px 30px rgba(0, 100, 255, ${0.2 + expandProgress * 0.3})`;
          }
        }
        
        if (e.touches) e.preventDefault();
      }
      
      handleGestureEnd(e) {
        if (!this.isDragging) return;
        
        const clientY = e.changedTouches ? e.changedTouches[0].clientY : this.currentY || this.startY;
        const deltaY = clientY - this.startY;
        const duration = Math.max(1, Date.now() - this.startTime);
        const velocity = -deltaY / duration; // Negative for upward
        
        this.isDragging = false;
        
        // Determine snap target
        const viewportHeight = window.innerHeight;
        const currentHeight = this.el.offsetHeight;
        const currentTranslateY = this.getCurrentTranslateY();
        
        // Beautiful easing for snap
        this.el.style.transition = 'all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
        this.backdrop.style.transition = 'opacity 0.4s ease';
        
        // Velocity-based or position-based decision
        let targetSnap;
        
        if (Math.abs(velocity) > 0.5) {
          // Fast swipe - respect velocity
          if (velocity > 0) {
            // Fast upward - expand
            targetSnap = this.SNAP_POINTS.FULL;
          } else {
            // Fast downward - close
            targetSnap = this.SNAP_POINTS.CLOSED;
          }
        } else {
          // Slow drag - find nearest snap
          if (currentTranslateY > 120) {
            targetSnap = this.SNAP_POINTS.CLOSED;
          } else if (currentHeight > viewportHeight * 0.7) {
            targetSnap = this.SNAP_POINTS.FULL;
          } else {
            targetSnap = this.SNAP_POINTS.HALF;
          }
        }
        
        // Snap to target
        this.snapTo(targetSnap);
      }
      
      getCurrentTranslateY() {
        const transform = window.getComputedStyle(this.el).transform;
        if (transform && transform !== 'none') {
          const matrix = new DOMMatrix(transform);
          return matrix.m42;
        }
        return 0;
      }
      
      snapTo(target) {
        const viewportHeight = window.innerHeight;
        
        if (target === this.SNAP_POINTS.CLOSED) {
          // Close drawer
          this.el.style.transform = 'translateY(400px)';
          this.el.style.height = '400px';
          this.backdrop.style.opacity = '0';
          
          setTimeout(() => {
            this.close();
            this.log('üëã Gesture closed');
          }, 400);
          
        } else if (target === this.SNAP_POINTS.FULL) {
          // Expand to fullscreen
          this.el.style.transform = 'translateY(0)';
          this.el.style.height = `${viewportHeight}px`;
          this.backdrop.style.opacity = '1.3';
          this.expanded = true;
          this.currentSnap = target;
          this.log('üì± Expanded to fullscreen');
          
        } else {
          // Normal half position
          this.el.style.transform = 'translateY(0)';
          this.el.style.height = '400px';
          this.backdrop.style.opacity = '1';
          this.expanded = false;
          this.currentSnap = target;
          this.log('‚Ü©Ô∏è Returned to normal');
        }
        
        // Clean up
        setTimeout(() => {
          this.el.style.transition = '';
          this.backdrop.style.transition = '';
          this.el.style.boxShadow = '0 -4px 20px rgba(0,0,0,0.1)';
        }, 400);
      }
      
      resetTransform() {
        this.el.style.transform = '';
        this.el.style.height = ''; // Reset height to original
      }
      
      log(message) {
        const logs = document.getElementById('logs');
        if (logs) {
          logs.textContent += '\n' + message;
          logs.scrollTop = logs.scrollHeight;
        }
        console.log(message);
      }
    }
    
    // Initialize world-class drawer
    const drawerElement = document.getElementById('test-drawer');
    const backdropElement = document.getElementById('drawer-backdrop');
    const drawer = new WorldClassDrawer(drawerElement, backdropElement);
    
    // Event listeners - direct, reliable
    document.getElementById('vanilla-drawer-trigger').addEventListener('click', () => drawer.open());
    document.getElementById('close-drawer').addEventListener('click', () => drawer.close());
    document.getElementById('drawer-backdrop').addEventListener('click', () => drawer.close());
    document.getElementById('force-open').addEventListener('click', () => drawer.open());
    document.getElementById('force-close').addEventListener('click', () => drawer.close());
    
    // Debug controls
    document.getElementById('debug-state').addEventListener('click', () => {
      const state = {
        opened: drawer.opened,
        hasClass: drawerElement.classList.contains('drawer-open'),
        transform: getComputedStyle(drawerElement).transform,
        backdropShow: backdropElement.classList.contains('show')
      };
      drawer.log(`State: ${JSON.stringify(state, null, 2)}`);
    });
    
    document.getElementById('clear-logs').addEventListener('click', () => {
      document.getElementById('logs').textContent = '‚úÖ World-class drawer initialized';
    });
    
    // Export API for tests
    window.demoAPI = {
      drawer: () => drawer,
      log: (message) => drawer.log(`[Demo] ${message}`)
    };
    
    /**
     * Embedded Test Runner - World Class Quality
     */
    const tests = [];
    let testResults = [];
    
    function test(name, testFn) {
      tests.push({ name, testFn });
    }
    
    async function runTests() {
      console.log('üß™ Starting world-class test suite...');
      testResults = [];
      
      for (const { name, testFn } of tests) {
        try {
          console.log(`Running: ${name}`);
          await testFn();
          testResults.push({ name, status: 'PASS', error: null });
          console.log(`‚úÖ PASS: ${name}`);
        } catch (error) {
          testResults.push({ name, status: 'FAIL', error: error.message });
          console.error(`‚ùå FAIL: ${name} - ${error.message}`);
        }
      }
      
      const passed = testResults.filter(r => r.status === 'PASS').length;
      const failed = testResults.filter(r => r.status === 'FAIL').length;
      
      console.log(`\\nüìä Test Results: ${passed} passed, ${failed} failed`);
      updateTestUI();
      
      return { passed, failed, results: testResults };
    }
    
    function updateTestUI() {
      const container = document.getElementById('test-results');
      if (!container) return;
      
      const passed = testResults.filter(r => r.status === 'PASS').length;
      const failed = testResults.filter(r => r.status === 'FAIL').length;
      
      container.innerHTML = `
        <h4>Test Results (${passed + failed} tests)</h4>
        <div class="test-summary ${failed > 0 ? 'fail' : 'pass'}">
          ‚úÖ ${passed} passed | ‚ùå ${failed} failed
        </div>
        <div class="test-details">
          ${testResults.map(result => `
            <div class="test-result ${result.status.toLowerCase()}">
              <span class="test-name">${result.name}</span>
              <span class="test-status">${result.status}</span>
              ${result.error ? `<div class="test-error">${result.error}</div>` : ''}
            </div>
          `).join('')}
        </div>
      `;
    }
    
    // Helper functions
    function waitFor(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function expectElement(selector) {
      const element = document.querySelector(selector);
      if (!element) {
        throw new Error(`Element not found: ${selector}`);
      }
      
      return {
        toExist: () => element,
        toHaveClass: (className) => {
          if (!element.classList.contains(className)) {
            throw new Error(`Element ${selector} does not have class: ${className}`);
          }
        },
        toNotHaveClass: (className) => {
          if (element.classList.contains(className)) {
            throw new Error(`Element ${selector} has class: ${className}`);
          }
        },
        toHaveText: (text) => {
          if (!element.textContent.includes(text)) {
            throw new Error(`Element ${selector} does not contain text: ${text}`);
          }
        }
      };
    }
    
    function clickElement(selector) {
      const element = document.querySelector(selector);
      if (!element) {
        throw new Error(`Element not found: ${selector}`);
      }
      element.click();
    }
    
    // Define world-class tests
    test('Demo API should initialize', async () => {
      if (!window.demoAPI) {
        throw new Error('demoAPI not found');
      }
      
      if (!window.demoAPI.drawer()) {
        throw new Error('Drawer instance not found');
      }
    });
    
    test('Drawer should exist in DOM', async () => {
      expectElement('#test-drawer').toExist();
      expectElement('#vanilla-drawer-trigger').toExist();
      expectElement('#drawer-backdrop').toExist();
    });
    
    test('Drawer should open on button click', async () => {
      // Initial state - should be closed
      expectElement('#test-drawer').toNotHaveClass('drawer-open');
      
      // Click trigger
      clickElement('#vanilla-drawer-trigger');
      
      // Wait for state update (immediate)
      await waitFor(50);
      
      // Check it opened
      expectElement('#test-drawer').toHaveClass('drawer-open');
      expectElement('#drawer-backdrop').toHaveClass('show');
    });
    
    test('Drawer should close with close button', async () => {
      // Ensure drawer is open first
      clickElement('#vanilla-drawer-trigger');
      await waitFor(50);
      expectElement('#test-drawer').toHaveClass('drawer-open');
      
      // Click close button
      clickElement('#close-drawer');
      await waitFor(50);
      
      // Should be closed
      expectElement('#test-drawer').toNotHaveClass('drawer-open');
      expectElement('#drawer-backdrop').toNotHaveClass('show');
    });
    
    test('Drawer should close with backdrop click', async () => {
      // Open drawer
      clickElement('#vanilla-drawer-trigger');
      await waitFor(50);
      expectElement('#test-drawer').toHaveClass('drawer-open');
      
      // Click backdrop
      clickElement('#drawer-backdrop');
      await waitFor(50);
      
      // Should be closed
      expectElement('#test-drawer').toNotHaveClass('drawer-open');
    });
    
    test('Force open should work', async () => {
      // Ensure closed first
      expectElement('#test-drawer').toNotHaveClass('drawer-open');
      
      // Force open
      clickElement('#force-open');
      await waitFor(50);
      
      // Should be open
      expectElement('#test-drawer').toHaveClass('drawer-open');
      expectElement('#drawer-backdrop').toHaveClass('show');
    });
    
    test('Force close should work', async () => {
      // Force open first
      clickElement('#force-open');
      await waitFor(50);
      expectElement('#test-drawer').toHaveClass('drawer-open');
      
      // Force close
      clickElement('#force-close');
      await waitFor(50);
      
      // Should be closed
      expectElement('#test-drawer').toNotHaveClass('drawer-open');
    });
    
    test('Debug state should show logs', async () => {
      // Clear logs
      clickElement('#clear-logs');
      await waitFor(50);
      
      // Debug state
      clickElement('#debug-state');
      await waitFor(50);
      
      // Check logs updated
      expectElement('#logs').toHaveText('State:');
    });
    
    test('Multiple open/close cycles should work', async () => {
      for (let i = 0; i < 3; i++) {
        // Open
        clickElement('#vanilla-drawer-trigger');
        await waitFor(50);
        expectElement('#test-drawer').toHaveClass('drawer-open');
        
        // Close
        clickElement('#close-drawer');
        await waitFor(50);
        expectElement('#test-drawer').toNotHaveClass('drawer-open');
      }
    });
    
    test('Gesture system should initialize properly', async () => {
      // Open drawer first
      clickElement('#vanilla-drawer-trigger');
      await waitFor(50);
      expectElement('#test-drawer').toHaveClass('drawer-open');
      
      // Verify gesture state (drawer should be listening for gestures)
      const drawerInstance = window.demoAPI.drawer();
      if (drawerInstance.isDragging !== false) {
        throw new Error('Drawer gesture state not properly initialized');
      }
      
      // Check logs for gesture initialization
      expectElement('#logs').toHaveText('Drawer opened');
    });
    
    // Export test runner
    window.testRunner = {
      runTests,
      tests,
      results: () => testResults
    };
    
    // Auto-run tests when page loads
    window.addEventListener('load', () => {
      setTimeout(() => {
        if (window.demoAPI) {
          runTests();
        } else {
          console.error('Demo API not found - tests cannot run');
        }
      }, 500);
    });
    
    console.log('‚úÖ World-class drawer initialized');
  </script>
</body>
</html>